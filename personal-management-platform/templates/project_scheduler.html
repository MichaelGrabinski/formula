{% extends 'base.html' %}

{% block content %}
<div class="space-y-6">
  <div class="flex items-center justify-between">
    <h1 class="text-2xl font-semibold">Project Scheduler</h1>
    <div class="text-sm text-muted-foreground">Default window: <span id="openWindowLabel">{{ open_start }} – {{ open_end }}</span></div>
  </div>

  <div class="grid grid-cols-1 xl:grid-cols-4 gap-6">
    <div class="xl:col-span-1 space-y-4">
      <form id="scheduler-filters" class="space-y-4">
        <div>
          <label class="block text-sm font-medium mb-1">Project</label>
          <select name="project" class="w-full border rounded px-2 py-1">
            <option value="">All projects</option>
            {% for p in projects %}
              <option value="{{ p.id }}" {% if selected_project == p.id %}selected{% endif %}>{{ p.name }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <div>
            <label class="block text-sm font-medium mb-1">Open start</label>
            <input type="time" name="open_start" value="{{ open_start }}" class="w-full border rounded px-2 py-1" />
          </div>
          <div>
            <label class="block text-sm font-medium mb-1">Open end</label>
            <input type="time" name="open_end" value="{{ open_end }}" class="w-full border rounded px-2 py-1" />
          </div>
        </div>
        <div class="border rounded p-3">
          <div class="font-medium mb-2">Advanced availability (per day)</div>
          {% for d in days %}
          <div class="grid grid-cols-3 gap-2 items-center mb-2">
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" name="day{{ forloop.counter0 }}_enabled" checked class="mr-1" />
              <span class="text-sm">{{ d|date:"D" }}</span>
            </label>
            <input type="time" name="day{{ forloop.counter0 }}_start" value="{{ open_start }}" class="w-full border rounded px-2 py-1" />
            <input type="time" name="day{{ forloop.counter0 }}_end" value="{{ open_end }}" class="w-full border rounded px-2 py-1" />
          </div>
          {% endfor %}
        </div>
  <button id="autoBtn" type="button" onclick="return window.scheduleNow && window.scheduleNow(event);" class="w-full px-3 py-2 rounded bg-primary text-primary-foreground">Auto-schedule</button>
      </form>

      <div class="border rounded p-3 space-y-2">
        <div class="font-medium">KPIs</div>
        <div class="text-sm">Total task hours: <span id="kpi_total_hours">{{ total_hours }}</span></div>
        <div class="text-sm">Weekly capacity: <span id="kpi_capacity">{{ capacity_hours }}</span></div>
        <div class="text-sm">Remaining: <span id="kpi_remaining">{{ remaining_hours }}</span></div>
      </div>

      <form id="icsForm" method="post" class="border rounded p-3 space-y-2">
        {% csrf_token %}
        <input type="hidden" name="action" value="export_ics" />
        <input type="hidden" id="schedule_json" name="schedule_json" value="{}" />
        <button type="submit" class="w-full px-3 py-2 rounded bg-secondary text-secondary-foreground">Export ICS</button>
      </form>
    </div>

    <div class="xl:col-span-3 space-y-6">
      <div>
        <h2 class="text-lg font-medium mb-2">Tasks</h2>
        <div id="taskTiles" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
          {% for t in tasks %}
          <div draggable="true" data-id="{{ t.id }}" data-title="{{ t.title }}" data-hours="{{ t.estimated_hours|default:0 }}" class="border rounded p-2 cursor-move bg-card">
            <div class="text-sm font-medium truncate">{{ t.title }}</div>
            <div class="text-xs opacity-80">{{ t.estimated_hours|default:0 }}h{% if t.project %} • {{ t.project.name }}{% endif %}</div>
          </div>
          {% empty %}
          <div class="text-sm text-muted-foreground">No tasks with estimated hours.</div>
          {% endfor %}
        </div>
      </div>

      <div>
        <h2 class="text-lg font-medium mb-2">This Week</h2>
        <div class="grid grid-cols-1 md:grid-cols-7 gap-2">
          {% for d in days %}
          <div class="border rounded p-2">
            <div class="text-sm font-medium mb-2">{{ d|date:"D M j" }}</div>
            <div class="dropzone relative border rounded h-[600px] bg-background/40 overflow-hidden" style="height:600px" data-date="{{ d|date:'Y-m-d' }}" data-index="{{ forloop.counter0 }}"></div>
          </div>
          {% endfor %}
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  (function(){
  console.log('Scheduler script loaded');
  // Helpers
  function getCookie(name){
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
  }
  function getDayWindow(idx, form){
    const params = new URLSearchParams(new FormData(form));
    const sVal = form.querySelector(`input[name=day${idx}_start]`)?.value || (params.get('open_start') || '18:00');
    const eVal = form.querySelector(`input[name=day${idx}_end]`)?.value || (params.get('open_end') || '22:00');
    const s = sVal.split(':').map(n=>parseInt(n,10));
    const e = eVal.split(':').map(n=>parseInt(n,10));
    const startMin = s[0]*60 + s[1];
    const endMin = e[0]*60 + e[1];
    const totalMin = Math.max(endMin - startMin, 1);
    return { sVal, eVal, startMin, endMin, totalMin };
  }
  function collectIntervals(z, totalMin){
    // Return sorted non-negative intervals for existing blocks within the zone
    const ivals = Array.from(z.children)
      .filter(el => el.dataset && el.dataset.duration)
      .map(el => {
        const dur = parseInt(el.dataset.duration||'0',10) || 0;
        let start = parseInt(el.dataset.start||'0',10) || 0;
        start = Math.max(0, Math.min(start, Math.max(totalMin - dur, 0)));
        return { start, end: start + dur, el };
      })
      .filter(x => x.end > x.start)
      .sort((a,b)=>a.start-b.start);
    return ivals;
  }
  function findPlacementGap(intervals, desiredStart, duration, totalMin){
    // Try desired start in its current gap; else search forward gaps; else search earlier gaps; returns start or null
    const step = 15; // minutes snapping
    function fitsAt(s){
      return s >= 0 && s + duration <= totalMin && intervals.every(iv => (s + duration <= iv.start) || (s >= iv.end));
    }
    // snap desired
    let s0 = Math.max(0, Math.min(desiredStart, totalMin - duration));
    s0 = Math.round(s0/step)*step;
    if (fitsAt(s0)) return s0;
    // Search forward by gaps
    let cursor = 0;
    for (const iv of intervals){
      if (cursor <= s0 && s0 < iv.start){
        // we already tried s0; set cursor to iv.end for next gap
      }
      // gap [cursor, iv.start)
      const gapStart = Math.max(cursor, 0);
      const gapEnd = Math.min(iv.start, totalMin);
      const gapLen = Math.max(gapEnd - gapStart, 0);
      if (gapLen >= duration){
        let s = Math.max(s0, gapStart);
        s = Math.round(s/step)*step;
        if (s + duration <= gapEnd && fitsAt(s)) return s;
        // try aligning to gapStart
        s = Math.round(gapStart/step)*step;
        if (s + duration <= gapEnd && fitsAt(s)) return s;
      }
      cursor = Math.max(cursor, iv.end);
    }
    // Last gap [cursor, totalMin)
    if (totalMin - cursor >= duration){
      let s = Math.max(s0, cursor);
      s = Math.round(s/step)*step;
      if (s + duration <= totalMin && fitsAt(s)) return s;
      s = Math.round(cursor/step)*step;
      if (s + duration <= totalMin && fitsAt(s)) return s;
    }
    // Search earlier gaps (backwards) for nearest fit
    cursor = totalMin;
    for (let i=intervals.length-1;i>=0;i--){
      const iv = intervals[i];
      const gapStart = Math.max(iv.end, 0);
      const gapEnd = Math.min(cursor, totalMin);
      const gapLen = Math.max(gapEnd - gapStart, 0);
      if (gapLen >= duration){
        let s = Math.min(s0, gapEnd - duration);
        s = Math.round(s/step)*step;
        if (s >= gapStart && s + duration <= gapEnd && fitsAt(s)) return s;
        s = Math.round((gapEnd - duration)/step)*step;
        if (s >= gapStart && fitsAt(s)) return s;
      }
      cursor = Math.min(cursor, iv.start);
    }
    // If nothing fits fully, try trimming into any gap (fallback minimal placement)
    for (const tryStep of [duration, Math.max(15, Math.floor(duration/2)), 30, 15]){
      cursor = 0;
      for (const iv of intervals){
        const gapStart = cursor;
        const gapEnd = iv.start;
        if (gapEnd - gapStart >= tryStep){
          let s = Math.round(Math.max(gapStart, Math.min(s0, gapEnd - tryStep))/step)*step;
          return s;
        }
        cursor = iv.end;
      }
      if (totalMin - cursor >= tryStep){
        let s = Math.round(Math.max(cursor, Math.min(s0, totalMin - tryStep))/step)*step;
        return s;
      }
    }
    return null;
  }
  function to12h(hhmm){
    const [h,m] = (hhmm||'00:00').split(':').map(x=>parseInt(x,10));
    const ampm = h>=12 ? 'PM' : 'AM';
    const h12 = ((h+11)%12)+1;
    return `${h12}:${String(m).padStart(2,'0')} ${ampm}`;
  }
  function labelOpenWindow(){
    const params = new URLSearchParams(new FormData(document.getElementById('scheduler-filters')));
    const s = params.get('open_start') || '18:00';
    const e = params.get('open_end') || '22:00';
    const el = document.getElementById('openWindowLabel');
    if (el) el.textContent = `${to12h(s)} – ${to12h(e)}`;
  }
  function hexToRgb(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex || '');
    return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : { r: 0, g: 0, b: 0 };
  }
  function alphaBg(hex, a){
    const {r,g,b} = hexToRgb(hex);
    return `rgba(${r}, ${g}, ${b}, ${a})`;
  }

  // Drag from tiles into a day
  const tiles = document.querySelectorAll('#taskTiles [draggable]');
  const zones = document.querySelectorAll('.dropzone');
  tiles.forEach(el => {
    el.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', JSON.stringify({ id: el.dataset.id, title: el.dataset.title, hours: parseFloat(el.dataset.hours || '0') }));
    });
  });
  function placeBlockAt(z, minutes, title, taskId, desiredStart){
    const idx = parseInt(z.getAttribute('data-index')||'0',10);
    const form = document.getElementById('scheduler-filters');
    const { startMin, totalMin } = getDayWindow(idx, form);
    const duration = Math.max(0, Math.min(minutes, totalMin));
    const intervals = collectIntervals(z, totalMin);
    const startOffset = findPlacementGap(intervals, Math.max(0, desiredStart??0), duration, totalMin);
    if (startOffset === null) return 0;
    const top = (startOffset/totalMin) * 100;
    const height = Math.max((duration/totalMin) * 100, 6);
    const startAbs = startMin + startOffset;
    const startH = Math.floor(startAbs/60), startM = startAbs%60;
    const endAbs = startAbs + duration;
    const endH = Math.floor(endAbs/60), endM = endAbs%60;
    const colors = ['#6ee7b7','#93c5fd','#fca5a5','#a78bfa','#fdba74','#38bdf8','#f472b6','#86efac'];
    const color = colors[(taskId||0) % colors.length];
    const block = document.createElement('div');
    block.className = 'relative rounded shadow-sm ring-1';
    block.style.position = 'absolute';
    block.style.left = '4px';
    block.style.right = '4px';
    block.style.top = `${top}%`;
    block.style.height = `${height}%`;
    block.style.backgroundColor = color + '33';
    block.style.borderColor = color;
    block.style.boxShadow = `0 1px 2px 0 ${color}66`;
    block.dataset.id = taskId;
    block.dataset.duration = String(duration);
    block.dataset.start = String(startOffset);
    block.draggable = true;
    block.addEventListener('dragstart', ev => {
      window.__dragBlockEl = block;
      ev.dataTransfer.setData('text/plain', JSON.stringify({ id: taskId, title, minutes: duration, move: true }));
    });
    block.innerHTML = `<div class="text-xs p-1">
      <div class="font-medium truncate">${title}</div>
      <div class="opacity-80">${to12h(`${String(startH).padStart(2,'0')}:${String(startM).padStart(2,'0')}`)} – ${to12h(`${String(endH).padStart(2,'0')}:${String(endM).padStart(2,'0')}`)} • ${Math.round((duration/60)*10)/10}h</div>
    </div>`;
    z.appendChild(block);
    return duration;
  }
  zones.forEach(z => {
    z.addEventListener('dragover', e => {
      e.preventDefault();
    });
    z.addEventListener('drop', e => {
      e.preventDefault();
      let data;
      try { data = JSON.parse(e.dataTransfer.getData('text/plain')); } catch { return; }
      if (window.__dragBlockEl && window.__dragBlockEl.parentElement) {
        try { window.__dragBlockEl.parentElement.removeChild(window.__dragBlockEl); } catch {}
        window.__dragBlockEl = null;
      }
      const minutes = Math.round((data.minutes ?? ((data.hours||0)*60)));
      if (!minutes || minutes <= 0) return;
      // Compute desired start from mouse position within zone
      const rect = z.getBoundingClientRect();
      const relY = Math.min(Math.max((e.clientY - rect.top), 0), rect.height);
      const idx = parseInt(z.getAttribute('data-index')||'0',10);
      const form = document.getElementById('scheduler-filters');
      const { totalMin } = getDayWindow(idx, form);
      const pct = rect.height ? (relY / rect.height) : 0;
      const desired = Math.round((pct * totalMin) / 15) * 15; // snap to 15 minutes
      placeBlockAt(z, minutes, data.title || 'Task', parseInt(data.id||'0',10), desired);
    });
  });

  // Auto schedule
  window.scheduleNow = async function(e){
    console.log('Auto-schedule clicked');
    const btn = document.getElementById('autoBtn');
    if (e && e.preventDefault) e.preventDefault();
    if (btn) {
      if (btn.dataset.running === '1') return false;
      btn.dataset.running = '1';
      btn.disabled = true;
      btn.dataset._label = btn.textContent;
      btn.textContent = 'Scheduling…';
    }
    const form = document.getElementById('scheduler-filters');
    const params = new URLSearchParams(new FormData(form));
    const body = new URLSearchParams(params);
    body.append('action', 'auto_schedule');
    for (let i=0;i<7;i++){
      const en = form.querySelector(`input[name=day${i}_enabled]`);
      const st = form.querySelector(`input[name=day${i}_start]`);
      const et = form.querySelector(`input[name=day${i}_end]`);
      if (en) body.append(`day${i}_enabled`, en.checked ? '1' : '0');
      if (st && st.value) body.append(`day${i}_start`, st.value);
      if (et && et.value) body.append(`day${i}_end`, et.value);
    }
    const csrfInput = document.querySelector('#icsForm input[name=csrfmiddlewaretoken]');
    const csrf = csrfInput ? csrfInput.value : (getCookie('csrftoken') || '');
    let res;
    try {
      res = await fetch('', { method: 'POST', headers: { 'X-CSRFToken': csrf, 'Content-Type': 'application/x-www-form-urlencoded' }, credentials: 'same-origin', body });
    } catch (e) {
      console.error('Auto-schedule network error', e);
      alert('Auto-schedule failed due to a network error.');
  if (btn) { btn.disabled = false; btn.textContent = btn.dataset._label || 'Auto-schedule'; btn.dataset.running = '0'; }
      return;
    }
    if (!res.ok) {
      const txt = await res.text();
      console.error('Auto-schedule server error', res.status, txt);
      alert('Auto-schedule failed. See console for details.');
  if (btn) { btn.disabled = false; btn.textContent = btn.dataset._label || 'Auto-schedule'; btn.dataset.running = '0'; }
      return;
    }
    const ctype = (res.headers.get('content-type')||'').toLowerCase();
    if (!ctype.includes('application/json')) {
      const txt = await res.text();
      console.error('Unexpected response (not JSON). Possibly a login page or template error.', txt.slice(0, 500));
      alert('Auto-schedule did not return JSON (are you logged in?).');
  if (btn) { btn.disabled = false; btn.textContent = btn.dataset._label || 'Auto-schedule'; btn.dataset.running = '0'; }
      return;
    }
    let sched;
    try {
      sched = await res.json();
    } catch (e) {
      console.error('Failed to parse schedule JSON', e);
      alert('Auto-schedule returned invalid JSON.');
  if (btn) { btn.disabled = false; btn.textContent = btn.dataset._label || 'Auto-schedule'; btn.dataset.running = '0'; }
      return;
    }
    console.log('Schedule payload:', sched);
    // Clear all zones before rendering
    document.querySelectorAll('.dropzone').forEach(z => z.innerHTML = '');
    let placed = 0;
    (sched.days || []).forEach(day => {
      const z = document.querySelector('.dropzone[data-date="' + day.date + '"]');
      if (!z) return;
      const idx = parseInt(z.getAttribute('data-index')||'0',10);
      const formEl = document.getElementById('scheduler-filters');
      const dayEnabled = formEl.querySelector(`input[name=day${idx}_enabled]`)?.checked ?? true;
      if (!dayEnabled) return;
  const { startMin, totalMin } = getDayWindow(idx, formEl);
  const colors = ['#6ee7b7','#93c5fd','#fca5a5','#a78bfa','#fdba74','#38bdf8','#f472b6','#86efac'];
      // Sort blocks by start time to avoid overlap ordering
      const sortedBlocks = [...(day.blocks || [])].sort((a,b)=>{
        const [ah,am]=(a.start||'00:00').split(':').map(n=>parseInt(n,10));
        const [bh,bm]=(b.start||'00:00').split(':').map(n=>parseInt(n,10));
        return (ah*60+am) - (bh*60+bm);
      });
      // Add a small counter label for quick visual confirmation
      const counter = document.createElement('div');
      counter.className = 'absolute top-1 right-1 text-[11px] px-1.5 py-0.5 rounded';
      counter.style.background = 'rgba(0,0,0,0.35)';
      counter.style.color = '#fff';
      counter.style.pointerEvents = 'none';
      counter.style.zIndex = '20';
      counter.textContent = `${sortedBlocks.length} blk${sortedBlocks.length===1?'':'s'}`;
      z.appendChild(counter);
      let lastBottomPct = 0;
      sortedBlocks.forEach((b, i) => {
  const startParts = (b.start||'18:00').split(':').map(n=>parseInt(n,10));
  const startAbs = startParts[0]*60 + startParts[1];
  const offset = Math.max(startAbs - startMin, 0);
        let height = Math.max((b.duration/totalMin) * 100, 6);
        let top = (offset/totalMin) * 100;
        // keep a tiny vertical gap between sequential blocks
        const minGap = 1; // 1%
        if (top < lastBottomPct + minGap) {
          top = lastBottomPct + minGap;
        }
        // Clamp to container bounds
        if (top + height > 100) {
          height = Math.max(3, 100 - top);
        }
        const color = colors[(b.task_id || i) % colors.length];
  const block = document.createElement('div');
        block.className = 'relative rounded shadow-sm ring-1';
        block.style.position = 'absolute';
        block.style.left = '4px';
        block.style.right = '4px';
        block.style.top = `${top}%`;
        block.style.height = `${height}%`;
  block.style.minHeight = '20px';
  block.style.backgroundColor = alphaBg(color, 0.25);
  block.style.border = `1px solid ${color}`;
  block.style.borderColor = color;
  block.style.boxShadow = `0 1px 2px 0 ${alphaBg(color,0.4)}`;
  block.style.zIndex = '10';
        block.dataset.id = b.task_id;
  block.dataset.duration = String(b.duration);
  block.dataset.start = String(Math.max(0, Math.min(offset, Math.max(totalMin - b.duration, 0))));
        block.draggable = true;
        block.addEventListener('dragstart', ev => {
          window.__dragBlockEl = block;
          ev.dataTransfer.setData('text/plain', JSON.stringify({ id: b.task_id, title: b.title, minutes: b.duration, move: true }));
        });
        block.innerHTML = `<div class="text-xs p-1">
          <div class="font-medium truncate">${b.title}</div>
          <div class="opacity-80">${to12h(b.start)} – ${to12h(b.end)} • ${Math.round((b.duration/60)*10)/10}h</div>
        </div>`;
        z.appendChild(block);
        lastBottomPct = top + height;
        placed++;
      });
    });
  console.log('Placed blocks:', placed);
  if (btn) { btn.disabled = false; btn.textContent = btn.dataset._label || 'Auto-schedule'; btn.dataset.running = '0'; }
    if (placed === 0) {
      alert('No tasks were scheduled. Ensure your tasks have estimated_hours > 0 and your availability has capacity.');
    }
    window.__lastSchedule = sched;
    try {
      const total = Array.from(document.querySelectorAll('#taskTiles [draggable]'))
        .reduce((acc, el) => acc + (parseFloat(el.dataset.hours||'0')||0), 0);
      const form = document.getElementById('scheduler-filters');
      // Sum actual enabled per-day availability instead of assuming 7 identical days
      let totalMinutes = 0;
      for (let i=0;i<7;i++){
        const en = form.querySelector(`input[name=day${i}_enabled]`);
        const st = form.querySelector(`input[name=day${i}_start]`);
        const et = form.querySelector(`input[name=day${i}_end]`);
        const enabled = !en || en.checked;
        const sVal = (st && st.value) || new URLSearchParams(new FormData(form)).get('open_start') || '18:00';
        const eVal = (et && et.value) || new URLSearchParams(new FormData(form)).get('open_end') || '22:00';
        const [sh, sm] = sVal.split(':').map(x=>parseInt(x,10));
        const [eh, em] = eVal.split(':').map(x=>parseInt(x,10));
        const mins = Math.max(((eh*60+em) - (sh*60+sm)), 0);
        totalMinutes += enabled ? mins : 0;
      }
      const capacity = Math.round((totalMinutes/60)*100)/100;
      document.getElementById('kpi_total_hours').textContent = (Math.round(total*100)/100).toFixed(2);
      document.getElementById('kpi_capacity').textContent = capacity.toFixed(2);
      document.getElementById('kpi_remaining').textContent = (capacity - total).toFixed(2);
    } catch (e) { /* noop */ }
    return false;
  };

  // Also bind programmatically (in case inline is stripped by CSP or disabled)
  // Bind programmatically once (still have inline fallback)
  (function(){
    const btn = document.getElementById('autoBtn');
    if (btn && !btn.__bound) { btn.addEventListener('click', window.scheduleNow); btn.__bound = true; }
  })();

  // Initialize
  labelOpenWindow();
  const icsForm = document.getElementById('icsForm');
  icsForm?.addEventListener('submit', function(){
    const sched = window.__lastSchedule || { days: [] };
    document.getElementById('schedule_json').value = JSON.stringify(sched);
  });

  // Restore persisted schedule if provided by server
  try {
    const savedEl = document.getElementById('savedScheduleJson');
    const saved = savedEl ? JSON.parse(savedEl.textContent || 'null') : null;
    if (saved && saved.days && Array.isArray(saved.days)) {
      document.querySelectorAll('.dropzone').forEach(z => z.innerHTML = '');
      let count = 0;
      saved.days.forEach(day => {
        const z = document.querySelector(`.dropzone[data-date="${day.date}"]`);
        if (!z) return;
        const idx = parseInt(z.getAttribute('data-index')||'0',10);
        const form = document.getElementById('scheduler-filters');
        const { startMin } = getDayWindow(idx, form);
        // Counter badge
        const counter = document.createElement('div');
        counter.className = 'absolute top-1 right-1 text-[11px] px-1.5 py-0.5 rounded';
        counter.style.background = 'rgba(0,0,0,0.35)';
        counter.style.color = '#fff';
        counter.style.pointerEvents = 'none';
        counter.style.zIndex = '20';
        counter.textContent = `${(day.blocks||[]).length} blk${(day.blocks||[]).length===1?'':'s'}`;
        z.appendChild(counter);
        (day.blocks||[]).forEach((b, i) => {
          const [sh, sm] = String(b.start||'18:00').split(':').map(n=>parseInt(n,10));
          const startAbs = sh*60 + sm;
          const offset = Math.max(0, startAbs - startMin);
          const duration = parseInt(b.duration||'0',10) || 0;
          placeBlockAt(z, duration, b.title || 'Task', parseInt(b.task_id||i,10), offset);
          count++;
        });
      });
      console.log('Restored saved schedule blocks:', count);
      // Mirror into lastSchedule so ICS export works without a new autoschedule
      window.__lastSchedule = saved;
    }
  } catch (e) {
    console.warn('No saved schedule to restore or failed to parse.', e);
  }
  })();
</script>
{% if saved_schedule %}
<script id="savedScheduleJson" type="application/json">{{ saved_schedule|json_script:"ignore" }}</script>
{% endif %}
{% endblock %}
